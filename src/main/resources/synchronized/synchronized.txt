synchronized锁:由对象头中的Mark Word根据锁标志位的不同而被复用及锁升级策略

1.锁升级(结合锁升级.png)
偏向锁:MarkWord存储的是偏向的线程ID
轻量锁:MarkWord存储的是指向线程栈中Lock Record的指针
重量锁:MarkWord存储的是指向堆中的monitor对象的指针

2.偏向锁
当一段同步代码一直被同一个线程多次访问,由于只有一个线程那么该线程在后续访问时便会自动获得锁
JVM不用和操作系统协商设置Mutex(争取内核),它只需要记录下线程ID就标示自己获得了当前锁,不用操作系统接入。
上述就是偏向锁：在没有其他线程竞争的时候,一直偏向偏心当前线程，当前线程可以一直执行。

3.偏向锁的撤销
偏向锁使用一种等到竞争出现才释放锁的机制,只有当其他线程竞争锁时,持有偏向锁的原来线程才会被撤销。
撤销需要等待全局安全点(该时间点上没有字节码正在执行),同时检查持有偏向锁的线程是否还在执行：

① 第一个线程正在执行synchronized方法(处于同步块),它还没有执行完,其它线程来抢夺,该偏向锁会被取消掉并出现锁升级。
此时轻量级锁由原持有偏向锁的线程持有,继续执行其同步代码,而正在竞争的线程会进入自旋等待获得该轻量级锁。
② 第一个线程执行完成synchronized方法(退出同步块),则将对象头设置成无锁状态并撤销偏向锁,重新偏向。

Java15后偏向锁废除

4.轻量级锁
多线程竞争,但是任意时刻最多只有一个线程竞争,即不存在锁竞争太过激烈的情况,也就没有线程阻塞
有线程来参与锁的竞争，但是获取锁的冲突时间极短;本质就是自旋锁

5.自旋达到一定次数和程度
Java6之前
默认启用,默认情况下自旋的次数是10次  -XX:PreBlockSpin=10来修改,或者自旋线程数超过cpu核数一半

Java6之后
自适应,自适应意味着自旋的次数不是固定不变的
而是根据：同一个锁上一次自旋的时间,拥有锁线程的状态来决定。

6.轻量锁与偏向锁的区别和不同
争夺轻量级锁失败时,自旋尝试抢占锁
轻量级锁每次退出同步块都需要释放锁,而偏向锁是在竞争发生时才释放锁

7.锁升级之后,hashcode等信息去哪了?
锁升级后和hashcode的关系-1.png
锁升级后和hashcode的关系-2.png
1)当一个对象已经计算过identity hash code 它就无法进入偏向锁状态
2)偏向锁过程中遇到一致性哈希计算请求,立马撤销偏向模式,膨胀为重量级锁

8.各种锁优缺点、synchronized锁升级和实现原理
各种锁优缺点.png
偏向锁:适用于单线程适用的情况,在不存在锁竞争的时候进入同步方法/代码块则使用偏向锁。
轻量级锁:适用于竞争较不激烈的情况(这和乐观锁的使用范围类似),存在竞争时升级为轻量级锁,轻量级锁采用的是自旋锁,如果同步方法/代码块执行时间很短的话,采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。
重量级锁:适用于竞争激烈的情况,如果同步方法/代码块执行时间很长,那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重,这时候就需要升级为重量级锁。

9.锁消除与锁粗话
详见代码
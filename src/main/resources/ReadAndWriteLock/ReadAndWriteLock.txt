ReentrantReadWriteLock只允许读读共存,而读写和谢谢依然是互斥的
同时只能存在一个写锁但是可以存在多个读锁,但不能同时存在写锁和读锁,
也即一个资源可以被多个读操作访问或一个写操作访问,但两者不能同时进行

1.读写锁,锁饥饿问题是什么?
写锁饥饿(读的线程太多,写锁抢不到)
一体两面,读写互斥,读读共享,读没有完成的时候其他线程写锁无法获得

2.有没有比读写锁更快的锁?
邮戳锁/版本锁/票据锁

3.StampedLock知道吗(邮戳锁/票据锁)
为了解决读写锁的锁饥饿问题引出的

4.ReentrantReadWriteLock有锁降级机制,是什么?
可以查看该类Oracle提供的代码
如果遵循锁降级的步骤
    - 线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。
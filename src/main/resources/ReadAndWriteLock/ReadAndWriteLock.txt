ReentrantReadWriteLock只允许读读共存,而读写和谢谢依然是互斥的
同时只能存在一个写锁但是可以存在多个读锁,但不能同时存在写锁和读锁,
也即一个资源可以被多个读操作访问或一个写操作访问,但两者不能同时进行

1.读写锁,锁饥饿问题是什么?
写锁饥饿(读的线程太多,写锁抢不到)
一体两面,读写互斥,读读共享,读没有完成的时候其他线程写锁无法获得

2.有没有比读写锁更快的锁?
邮戳锁/版本锁/票据锁

3.StampedLock知道吗(邮戳锁/票据锁)
为了解决读写锁的锁饥饿问题引出的
特点:
    - 所有获取锁的方法,都返回一个邮戳(Stamp),Stamp为零表示获取失败，其余都表示成功;
    - 所有释放锁的方法,都需要一个邮戳(Stamp),这个Stamp必须是和成功获取锁时得到的Stamp一致;
    - StampedLock是不可重入的,危险(如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)
三种访问模式:
    - Reading(读模式):功能和ReentrantReadWriteLock的读锁类似
    - Writing(写模式):功能和ReentrantReadWriteLock的写锁类似
    - Optimistic reading(乐观读模式):无锁机制,类似于数据库中的乐观锁,支持读写并发,很乐观认为读取时没人修改,假如被修改再实现升级为悲观读模式

4.ReentrantReadWriteLock有锁降级机制,是什么?
可以查看该类Oracle提供的代码
如果遵循锁降级的步骤
    - 线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。
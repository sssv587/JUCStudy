1.基本类型原子类
- AtomicInteger
- AtomicBoolean
- AtomicLong

2.数组类型原子类
- AtomicIntegerArray
- AtomicLongArray
- AtomicReferenceArray

3.引用类型原子类
- AtomicReference
- AtomicStampedReference
    - 携带版本号的引用类型原子类，可以解决ABA问题
    - 解决修改过几次
    - 状态戳原子引用
- AtomicMarkableReference
    - 原子更新带有标记位的引用类型对象
    - 解决是否修改过 它的定义就是将状态戳简化为true|false -- 类似一次性筷子

4.对象的属性修改原子类
使用目的:以一种线程安全的方式操作非线程安全对象内的某些字段
使用要求:
    1)更新的对象属性必须使用 public volatile 修饰符。
    2)因为对象的属性修改类型原子类都是抽象类,所以每次使用都必须使用静态方法newUpdater()创建一个更新器,并且需要设置想要更新的类和属性。
- AtomicIntegerFieldUpdater
  - 原子更新对象中int类型字段的值
- AtomicLongFieldUpdater
  - 原子更新对象中Long类型字段的值
- AtomicReferenceFieldUpdater
  - 原子更新引用类型字段的值

5.原子操作增强类原理深度解析
- DoubleAccumulator
- DoubleAdder
- LongAccumulator
- LongAdder

6.原子类LongAdder高性能原理说明
化整为零,分散热点,降低更新热点
统计求和的话:result=base+Cell数组
上述两者全部,才是最后结果

7.LongAdder原码分析
public void add(long x) {
    //as表示cells引用,b表示获取的base值,v表示期望值,m表示cells数组的长度,a表示当前线程中的cell单元格
    Cell[] as; long b, v; int m; Cell a;
    if ((as = cells) != null || !casBase(b = base, b + x)) {
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[getProbe() & m]) == null ||
            !(uncontended = a.cas(v = a.value, v + x)))
            longAccumulate(x, null, uncontended);
    }
}
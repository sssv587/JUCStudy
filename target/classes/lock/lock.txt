"锁"
1.乐观锁和悲观锁
    悲观锁:认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
            synchronized关键字和Lock的实现类都是悲观锁
         使用场景:适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源
    乐观锁:认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据
          如果这个数据没有被更新，当前线程将自己修改的数据成功写入。
          如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作
          使用场景:适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升
        一般有两种实现方式：
        1. 采用版本号Version机制
        2. CAS(Compare-and-Swap，即比较并替换)算法实现
2.公平锁和非公平锁
3.可重入锁(又名递归锁)
4.死锁
5.写锁(独占锁)/读锁(共享锁)
6.自旋锁SpinLock
7.无锁->独占锁->读写锁->邮戳锁
8.无锁->偏向锁->轻量锁->重量锁
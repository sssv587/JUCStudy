"锁"
1.乐观锁和悲观锁
    悲观锁:认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
            synchronized关键字和Lock的实现类都是悲观锁
         使用场景:适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源
    乐观锁:认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据
          如果这个数据没有被更新，当前线程将自己修改的数据成功写入。
          如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作
          使用场景:适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升
        一般有两种实现方式：
        1. 采用版本号Version机制
        2. CAS(Compare-and-Swap，即比较并替换)算法实现
2.公平锁和非公平锁
    公平锁:是指多个线程按照申请锁的顺序来获取锁,类似排队买票 ReentrantLock lock = new ReentrantLock(true);
    非公平锁:是指多个线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获得锁
        在高并发环境下,有可能造成优先级反转或者饥饿的状态 ReentrantLock lock = new ReentrantLock(false);//默认

    为什么会有公平锁与非公平锁的设计?为什么默认非公平?
    1.恢复挂起的线程到真正锁的获取还是有时间差的,从开发人员来看这个时间微乎其微,但是从CPU的角度来看,这个事件差存在的还是很明显的。
        所以非公平锁能更充分的利用CPU的时间片,尽量减少CPU空闲状态时间
    2.使用多线程很重要的考量点就是线程切换的开销,当采用非公平锁时,当一个线程请求锁获取同步状态,然后释放同步状态,所以刚释放锁的线程
        在此刻再次获取同步状态的概率就变得非常大,所以就减少了线程的开销

    什么时候用公平锁?什么时候用非公平锁?
    如果为了更高的吞吐量,很显然非公平锁是比较合适的,因为节省很多线程切换时间,吞吐量自然就上去了
    否则那就用公平锁,大家公平使用
3.可重入锁(又名递归锁)
    是指在同一个线程在外层方法获取锁的时候,再进入该线程的内层方法会自动获取锁(前提,锁对象得是同一个对象),不会因为之前已经获取过还没释放而阻塞
    如果是1个有 synchronized 修饰的递归调用方法,程序第2次进入被自己阻塞了岂不是天大的笑话,出现了作茧自缚。
    所以Java中ReentrantLock和synchronized都是可重入锁,可重入锁的一个优点是可一定程度避免死锁
    可：可以。
    重：再次。
    入：进入。
    锁：同步锁。
    进入什么:进入同步域（即同步代码块/方法或显式锁锁定的代码）
    一句话:一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁
4.死锁
5.写锁(独占锁)/读锁(共享锁)
6.自旋锁SpinLock
7.无锁->独占锁->读写锁->邮戳锁
8.无锁->偏向锁->轻量锁->重量锁